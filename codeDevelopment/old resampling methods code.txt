def ResampleMean(data, weights=None, iters=1000):
    """Uses sampling with replacement to generate a sampling distribution of mean for a variable.
    Can then make an rv of the sampling distribution to calculate the sampling distribution mean, 
    std deviation (std error), and confidence interval (rv.interval). 
    Using the rv, can also plot the cdf and compute the one-sided p-value of a hypothesized mean (eg. rv.cdf at 0). 
    A two-sided p-value can be obtained by doubling the one-sided p-value if appropriate for the particular case.
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        data (array-like): Data for the variable of interest
        weights (array-like, optional): Can include weights for the data. Used as DataFrame.sample parameter. Defaults to None.
        iters (int, optional): The number of resampling iterations. Defaults to 1000.

    Returns:
        mean_estimates (array): A mean estimates sampling distribution
    """
    # Resample with replacement, calculating the mean of the data and building a list of mean estimates
    if weights is None:   # In case of no weights, use a Series
        s = pd.Series(data)
        mean_estimates = [s.sample(n=len(s), replace=True).mean() for _ in range(iters)]
    
    else:    # In case of weights use a DataFrame
        df = pd.DataFrame({'data':data,'wgt':weights})
        mean_estimates = [df.sample(n=len(df), replace=True, weights=df.wgt).data.mean() for _ in range(iters)]
    
    return np.array(mean_estimates)


def ResampleDiffMeansH0(a, b, iters=1000, onesided=False):
    """Generates a difference in means sampling distribution for the null hypothesis that two groups are the same via permutation (randomized shuffling) of pooled data. 
    Can then make an rv of this distribution to plot the cdf and compute the p-value of of the actual difference (eg. rv.cdf at the actual difference). 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        a (array-like): Input data set 1
        b (array-like): Input data set 2
        iters (int): The number of simulations to run (Defaults to 1000)
        onesided (bool): If set to True a onesided test, that does not use absolute value of difference, is run (Defaults to False) 

    Returns:
        test_diff: Original actual difference in means value
        diff_mean_results (array): Sampling distribution for the null hypothesis obtained from resampling
    """
    a = np.array(a)
    b = np.array(b)
    
    # Combine the two data sets
    a_size = len(a)
    pooled_data = np.hstack((a, b))

    diff_mean_results = []
    
    if onesided == False:
        test_diff = abs(a.mean() - b.mean()) # The test stat if twosided

        for _ in range(iters):
            np.random.shuffle(pooled_data)
            group1 = pooled_data[:a_size]
            group2 = pooled_data[a_size:]
            result = abs(group1.mean() - group2.mean())
            diff_mean_results.append(result)
    
    elif onesided == True:
        test_diff = a.mean() - b.mean() # The test stat if onesided

        for _ in range(iters):
            np.random.shuffle(pooled_data)
            group1 = pooled_data[:a_size]
            group2 = pooled_data[a_size:]
            result = group1.mean() - group2.mean()
            diff_mean_results.append(result)
     
    else:
        raise TypeError('\'onesided\' parameter only accepts Boolean True or False')
    
    return test_diff, np.array(diff_mean_results)


def ResampleDiffMeansHa(a, b, iters=1000):
    """Generates a difference in means sampling distribution for the alternative hypothesis that two groups differ via resampling of each group. 
    In this case the resampling is done on each sample separately. 
    (ie. assuming the alternative hypothesis that the samples are different) 
    Can then make an rv of this distribution to calculate sampling distribution mean, std deviation (std error), and confidence interval (rv.interval). 
    Can also get a one-sided p-value for case of no difference null hypothesis using rv.cdf(0). 
    For two-sided p-value, can double the one-sided if sampling distribution is symmetrical or use the H0 version of this function. 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        a (array-like): Input data set 1
        b (array-like): Input data set 2
        iters (int, optional): The number of simulations to run (Defaults to 1000)
        
    Returns:
        test_diff: Original actual difference in means value
        diff_mean_results (array): Sampling distribution for the alternative hypothesis obtained from resampling
    """
    a=pd.Series(a)
    b=pd.Series(b)
    
    diff_mean_results = []
    
    test_diff = a.mean() - b.mean()
    
    for _ in range(iters):
        a_resample = a.sample(n=len(a), replace=True)
        b_resample = b.sample(n=len(b), replace=True)
        resample_diff = a_resample.mean() - b_resample.mean()
        diff_mean_results.append(resample_diff)
        
    return test_diff, np.array(diff_mean_results)


def ResampleCorrelationH0(x, y, iters=1000, onesided=False, method='pearson'):
    """Generates a correlation sampling distribution for the null hypothesis of no correlation between the variables via permutation of one of the variables. 
    Can then make an rv of this distribution to plot cdf, compute p-value for the actual correlation value (eg. rv.cdf at actual correlation(test_r)). 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        x (array-like): Input variable 1
        y (array-like): Input variable 2
        iters (int): The number of simulations to run (Defaults to 1000)
        onesided (bool): If set to True a onesided test, that does not use absolute value of difference, is run (Defaults to False)
        method (string): Select 'pearson' or 'spearman' method (default: 'pearson')

    Returns:
        test_r: Original actual correlation value
        corrs (array): Sampling distribution for the null hypothesis of no correlation obtained from resampling
    """
    xs, ys = np.array(x), np.array(y)
    
    if method == 'pearson':

        corrs=[]    
        if onesided == False:
            test_r = abs(stats.pearsonr(xs, ys)[0])

            for _ in range(iters):
                xs = np.random.permutation(xs)
                corr = abs(stats.pearsonr(xs, ys)[0])
                corrs.append(corr)

        elif onesided == True:
            test_r = stats.pearsonr(xs, ys)[0]

            for _ in range(iters):
                xs = np.random.permutation(xs)
                corr = stats.pearsonr(xs, ys)[0]
                corrs.append(corr)

        else:
            raise TypeError('\'onesided\' parameter only accepts Boolean True or False')
    
    elif method == 'spearman':

        corrs=[]    
        if onesided == False:
            test_r = abs(stats.spearmanr(xs, ys)[0])

            for _ in range(iters):
                xs = np.random.permutation(xs)
                corr = abs(stats.spearmanr(xs, ys)[0])
                corrs.append(corr)

        elif onesided == True:
            test_r = stats.spearmanr(xs, ys)[0]

            for _ in range(iters):
                xs = np.random.permutation(xs)
                corr = stats.spearmanr(xs, ys)[0]
                corrs.append(corr)

        else:
            raise TypeError('\'onesided\' parameter only accepts Boolean True or False')        
    
    else:
        raise Exception('Must enter either pearson or spearman as a string for method argument')       
    
    return test_r, np.array(corrs)


def ResampleCorrelationHa(x, y, iters=1000, method='pearson'):
    """Generates a correlation sampling distribution for the alternative hypothesis of correlation existing between the variables. 
    This is done by resampling x, y pairs and calculating correlation on new samples. 
    Can then make an rv of this distribution to calculate sampling distribution mean, std deviation (std error), and confidence interval (rv.interval). 
    Can also get a one-sided p-value for case of no difference null hypothesis using rv.cdf(0). 
    For two-sided p-value, can double the one-sided if sampling distribution is symmetrical or use the H0 version of this function. 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        x (array-like): Input variable 1
        y (array-like): Input variable 2
        iters (int): The number of simulations to run (Defaults to 1000)
        method (string): Select 'pearson' or 'spearman' method (default: 'pearson')
        
    Returns:
        actual_r: Original actual correlation value
        corrs (array): Sampling distribution for the alternative hypothesis of no correlation obtained from resampling
    """
    if method == 'pearson':  
        # Calculate actual correlation
        actual_r = stats.pearsonr(x, y)[0]

        # Create a dataframe to hold the x and y values as pairs
        df = pd.DataFrame({'x':x, 'y': y})

        corrs=[]    
        for _ in range(iters):
            sample = df.sample(n=len(df), replace=True)
            r = stats.pearsonr(sample.x, sample.y)[0]
            corrs.append(r)
    
    elif method == 'spearman':
        # Calculate actual correlation
        actual_r = stats.spearmanr(x, y)[0]

        # Create a dataframe to hold the x and y values as pairs
        df = pd.DataFrame({'x':x, 'y': y})

        corrs=[]    
        for _ in range(iters):
            sample = df.sample(n=len(df), replace=True)
            r = stats.spearmanr(sample.x, sample.y)[0]
            corrs.append(r)
    
    else:
        raise Exception('Must enter either pearson or spearman as a string for method argument')
      
    return actual_r, np.array(corrs)


def ResampleChiSquare(observed, expected, iters=1000):
    """Generates a chisquared statistic sampling distribution by randomly choosing values 
    according to the expected probablities to simulate the null hypothesis. 
    The sequences must be the same length, be integer counts of a categorical variable 
    and the sum of the sequence values must be the same. 
    If the sum of the sequence values is different, first normalize the expected values 
    and then create a new expected values sequence by multiplying by the total number of observed values. 
    adjust_expected = expected/sum(expected)*sum(observed) 
    Can then make an rv of this distribution to plot cdf and  
    compute a p-value for the actual chi-squared statistic (eg. rv.cdf at actual statistic (test_chi)). 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        observed (array-like): observed values sequence
        expected (array-like): expected values sequence
        iters (int, optional): Number of iterations to run when building distribution. Defaults to 1000.

    Returns:
        test_chi: Original actual chi squared value
        chis (array): Sampling distribution for the null hypothesis obtained from resampling
    """
    observed, expected = np.array(observed), np.array(expected)
    
    # Check that sum of values are equal
    if np.isclose(sum(observed), sum(expected)) == False:
        raise ValueError('The sum of the values for observed and expected must be equal.')
    
    # Calculate the chi square test statistic
    test_chi = sum((observed - expected)**2 / expected)
        
    # Calculate the variables needed for resampling
    n = sum(expected)
    values = list(range(len(expected)))
    p_exp = expected/sum(expected)
    
    # Build the chi square sampling distribution for the null hypothesis
    chis=[]
    for _ in range(iters):
        # Build a model_observed sequence generated by resampling using expected probabilities
        hist = Counter({x:0 for x in values})
        hist.update(np.random.choice(values, size=n, replace=True, p=p_exp))
        sorted_hist = sorted(hist.items())
        model_observed = np.array([x[1] for x in sorted_hist])

        # Compute chi square statistic and append
        chi = sum((model_observed - expected)**2 / expected)
        chis.append(chi)
    
    return test_chi, np.array(chis)


def ResampleChiSquareContingency(observed, iters=1000):
    """Generates a chisquared statistic sampling distribution 
    from a contingency table. 
    Can then make an rv of this distribution to plot cdf and  
    compute a p-value for the actual chi-squared statistic (eg. rv.cdf at actual statistic (test_chi)). 
    Can also use the 'min' and 'max' built-ins to find what the most extreme values are from the simluations.

    Args:
        observed (array-like): observed contingency table
        iters (int, optional): Number of iterations to run when building distribution. Defaults to 1000.

    Returns:
        test_chi: Original actual chi squared value
        chis (array): Sampling distribution for the null hypothesis obtained from resampling
    """
    # Put the data into array form
    observed = np.asarray(observed, dtype=np.float64)
    
    # Calculate the test chi square statistic and the expected array
    test_chi,_,_,expected = stats.chi2_contingency(observed)
    
    # Calculate variables to be used in resampling
    expected = np.asarray(expected, dtype=np.float64)
    expected_shape = expected.shape
    expected_ps = expected / np.sum(expected)
    values = np.array(list(range(len(expected.ravel())))) # Flatten the array and then reshape it later
    n= int(np.sum(expected))
      
    # Compute resampled expected values and compute chi square 
    # to build a sampling distribution that represents the null hypothesis
    chis=[]
    for _ in range(iters):
        hist = Counter({x:0 for x in values}) # Initiate an empty histogram to hold resampled values
        hist.update(np.random.choice(values, size=n, replace=True, p=expected_ps.ravel()))
        sorted_hist = sorted(hist.items())
        resampled_expected = np.array([x[1] for x in sorted_hist])
        resampled_expected_reshaped = resampled_expected.reshape(expected_shape) # Put back into original shape

        chi = stats.chi2_contingency(resampled_expected_reshaped)[0]
        chis.append(chi)

    return test_chi, np.array(chis)